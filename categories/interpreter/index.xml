<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Interpreter on 0xb1ns&gt;&gt; go run</title>
    <link>https://sbinet.github.io/categories/interpreter/</link>
    <description>Recent content in Interpreter on 0xb1ns&gt;&gt; go run</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 12 Sep 2016 14:35:31 +0200</lastBuildDate>
    
	<atom:link href="https://sbinet.github.io/categories/interpreter/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction to the pygo virtual machine</title>
      <link>https://sbinet.github.io/posts/2016-09-12-pygo-vm/</link>
      <pubDate>Mon, 12 Sep 2016 14:35:31 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2016-09-12-pygo-vm/</guid>
      <description>In the last episode, I have showed a rather important limitation of the tiny-interp interpreter:
def cond(): x = 3 if x &amp;lt; 5: return &amp;quot;yes&amp;quot; else: return &amp;quot;no&amp;quot;  Control flow and function calls were not handled, as a result tiny-interp could not interpret the above code fragment.
In the following, I&amp;rsquo;ll ditch tiny-interp and switch to the &amp;ldquo;real&amp;rdquo; pygo interpreter.
Real Python bytecode People having read the AOSA article know that the structure of the bytecode of the tiny-interp interpreter instruction set is in fact very similar to the one of the real python bytecode.</description>
    </item>
    
    <item>
      <title>A tiny python-like interpreter</title>
      <link>https://sbinet.github.io/posts/2016-09-09-tiny-interpreter/</link>
      <pubDate>Fri, 09 Sep 2016 10:37:07 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2016-09-09-tiny-interpreter/</guid>
      <description>Last episode saw me slowly building up towards setting the case for a pygo interpreter: a python interpreter in Go.
Still following the Python interpreter written in Python blueprints, let me first do (yet another!) little detour: let me build a tiny (python-like) interpreter.
A Tiny Interpreter This tiny interpreter will understand three instructions:
 LOAD_VALUE ADD_TWO_VALUES PRINT_ANSWER  As stated before, my interpreter doesn&amp;rsquo;t care about lexing, parsing nor compiling.</description>
    </item>
    
    <item>
      <title>Starting a Go interpreter</title>
      <link>https://sbinet.github.io/posts/2016-09-07-start-interpreter/</link>
      <pubDate>Wed, 07 Sep 2016 10:37:07 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2016-09-07-start-interpreter/</guid>
      <description>In this series of posts, I&amp;rsquo;ll try to explain how one can write an interpreter in Go and for Go. If, like me, you lack a bit in terms of interpreters know-how, you should be in for a treat.
Introduction Go is starting to get traction in the science and data science communities. And, why not? Go is fast to compile and run, is statically typed and thus presents a nice &amp;ldquo;edit/compile/run&amp;rdquo; development cycle.</description>
    </item>
    
  </channel>
</rss>