<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hep on 0xb1ns&gt;&gt; go run</title>
    <link>https://sbinet.github.io/categories/hep/</link>
    <description>Recent content in Hep on 0xb1ns&gt;&gt; go run</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 31 Jul 2018 10:22:04 +0200</lastBuildDate>
    
	<atom:link href="https://sbinet.github.io/categories/hep/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go-HEP Manifesto</title>
      <link>https://sbinet.github.io/posts/2018-07-31-go-hep-manifesto/</link>
      <pubDate>Tue, 31 Jul 2018 10:22:04 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2018-07-31-go-hep-manifesto/</guid>
      <description>Hello again.
I am starting today an article for arXiv about Go and Go-HEP. I thought structuring my thoughts a bit (in the form of a blog post) would help fluidify the process.
(HEP) Software is painful In my introduction talk(s) about Go and Go-HEP, such as here, I usually talk about software being painful. HENP software is no exception. It is painful.
As a C++/Python developer and former software architect of one of the four LHC experiments, I can tell you from vivid experience that software is painful to develop.</description>
    </item>
    
    <item>
      <title>Simple Monte Carlo with Gonum and Go-HEP</title>
      <link>https://sbinet.github.io/posts/2017-10-11-simple-mc/</link>
      <pubDate>Wed, 11 Oct 2017 16:20:00 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2017-10-11-simple-mc/</guid>
      <description>Today, we&amp;rsquo;ll investigate the Monte Carlo method. Wikipedia, the ultimate source of truth in the (known) universe has this to say about Monte Carlo:
Monte Carlo methods (or Monte Carlo experiments) are a broad class of computational algorithms that rely on repeated random sampling to obtain numerical results. (&amp;hellip;) Monte Carlo methods are mainly used in three distinct problem classes: optimization, numerical integration, and generating draws from a probability distribution.</description>
    </item>
    
    <item>
      <title>L3 LEP data</title>
      <link>https://sbinet.github.io/posts/2017-10-10-lep-data-minimization/</link>
      <pubDate>Tue, 10 Oct 2017 11:07:29 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2017-10-10-lep-data-minimization/</guid>
      <description>Still working our way through this tutorial based on C++ and MINUIT:
http://www.desy.de/~rosem/flc_statistics/data/04_parameters_estimation-C.pdf
Now, we tackle the L3 LEP data. L3 was an experiment at the Large Electron Positron collider, at CERN, near Geneva. Until 2000, it recorded the decay products of e+e- collisions at center of mass energies up to 208 GeV.
An example is the muon pair production:
$$ e^+ e^- \rightarrow \mu^+\mu^-$$ Both muons are mainly detected and reconstructed from the tracking system.</description>
    </item>
    
    <item>
      <title>Introduction to Minimization with Gonum</title>
      <link>https://sbinet.github.io/posts/2017-10-09-intro-to-minimization/</link>
      <pubDate>Mon, 09 Oct 2017 11:11:11 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2017-10-09-intro-to-minimization/</guid>
      <description>Switching gears a bit with regard to last week, let&amp;rsquo;s investigate how to perform minimization with Gonum.
In High Energy Physics, there is a program to calculate numerically:
 a function minimum of \(F(a)\) of parameters \(a_i\) (with up to 50 parameters), the covariance matrix of these parameters the (asymmetric or parabolic) errors of the parameters from \(F_{min}+\Delta\) for arbitrary \(\Delta\) the contours of parameter pairs \(a_i, a_j\).  This program is called MINUIT and was originally written by Fred JAMES in FORTRAN.</description>
    </item>
    
  </channel>
</rss>