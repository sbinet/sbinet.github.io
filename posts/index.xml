<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 0xb1ns&gt;&gt; go run</title>
    <link>https://sbinet.github.io/posts/</link>
    <description>Recent content in Posts on 0xb1ns&gt;&gt; go run</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 11 Oct 2017 16:20:00 +0200</lastBuildDate>
    
	<atom:link href="https://sbinet.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Simple Monte Carlo with Gonum and Go-HEP</title>
      <link>https://sbinet.github.io/posts/2017-10-11-simple-mc/</link>
      <pubDate>Wed, 11 Oct 2017 16:20:00 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2017-10-11-simple-mc/</guid>
      <description>Today, we&amp;rsquo;ll investigate the Monte Carlo method. Wikipedia, the ultimate source of truth in the (known) universe has this to say about Monte Carlo:
Monte Carlo methods (or Monte Carlo experiments) are a broad class of computational algorithms that rely on repeated random sampling to obtain numerical results. [&amp;hellip;] Monte Carlo methods are mainly used in three distinct problem classes: optimization, numerical integration, and generating draws from a probability distribution.</description>
    </item>
    
    <item>
      <title>L3 LEP data</title>
      <link>https://sbinet.github.io/posts/2017-10-10-lep-data-minimization/</link>
      <pubDate>Tue, 10 Oct 2017 11:07:29 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2017-10-10-lep-data-minimization/</guid>
      <description>Still working our way through this tutorial based on C++ and MINUIT:
http://www.desy.de/~rosem/flc_statistics/data/04_parameters_estimation-C.pdf
Now, we tackle the L3 LEP data. L3 was an experiment at the Large Electron Positron collider, at CERN, near Geneva. Until 2000, it recorded the decay products of e+e- collisions at center of mass energies up to 208 GeV.
An example is the muon pair production:
$$ e^+ e^- \rightarrow \mu^+\mu^-$$ Both muons are mainly detected and reconstructed from the tracking system.</description>
    </item>
    
    <item>
      <title>Introduction to Minimization with Gonum</title>
      <link>https://sbinet.github.io/posts/2017-10-09-intro-to-minimization/</link>
      <pubDate>Mon, 09 Oct 2017 11:11:11 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2017-10-09-intro-to-minimization/</guid>
      <description>Switching gears a bit with regard to last week, let&amp;rsquo;s investigate how to perform minimization with Gonum.
In High Energy Physics, there is a program to calculate numerically:
 a function minimum of F(a) of parameters a_i (with up to 50 parameters), the covariance matrix of these parameters the (asymmetric or parabolic) errors of the parameters from F_min+∆ for arbitrary ∆ the contours of parameter pairs a_i,a_j.  This program is called MINUIT and was originally written by Fred JAMES in FORTRAN.</description>
    </item>
    
    <item>
      <title>Introduction to Statistics With Gonum</title>
      <link>https://sbinet.github.io/posts/2017-10-04-intro-to-stats-with-gonum/</link>
      <pubDate>Wed, 04 Oct 2017 11:17:11 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2017-10-04-intro-to-stats-with-gonum/</guid>
      <description>Starting a bit of a new series (hopefully with more posts than with the interpreter ones) about using Gonum to apply statistics.
This first post is really just a copy-paste of this one:
https://mubaris.com/2017-09-09/introduction-to-statistics-using-numpy
but using Go and Gonum instead of Python and numpy.
Go &amp;amp; Gonum Gonum is &amp;ldquo;a set of packages designed to make writing numeric and scientific algorithms productive, performant and scalable.&amp;rdquo;
Before being able to use Gonum, we need to install Go.</description>
    </item>
    
    <item>
      <title>Introduction to the pygo virtual machine</title>
      <link>https://sbinet.github.io/posts/2016-09-12-pygo-vm/</link>
      <pubDate>Mon, 12 Sep 2016 14:35:31 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2016-09-12-pygo-vm/</guid>
      <description>In the last episode, I have showed a rather important limitation of the tiny-interp interpreter:
def cond(): x = 3 if x &amp;lt; 5: return &amp;quot;yes&amp;quot; else: return &amp;quot;no&amp;quot;  Control flow and function calls were not handled, as a result tiny-interp could not interpret the above code fragment.
In the following, I&amp;rsquo;ll ditch tiny-interp and switch to the &amp;ldquo;real&amp;rdquo; pygo interpreter.
Real Python bytecode People having read the AOSA article know that the structure of the bytecode of the tiny-interp interpreter instruction set is in fact very similar to the one of the real python bytecode.</description>
    </item>
    
    <item>
      <title>A tiny python-like interpreter</title>
      <link>https://sbinet.github.io/posts/2016-09-09-tiny-interpreter/</link>
      <pubDate>Fri, 09 Sep 2016 10:37:07 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2016-09-09-tiny-interpreter/</guid>
      <description>Last episode saw me slowly building up towards setting the case for a pygo interpreter: a python interpreter in Go.
Still following the Python interpreter written in Python blueprints, let me first do (yet another!) little detour: let me build a tiny (python-like) interpreter.
A Tiny Interpreter This tiny interpreter will understand three instructions:
 LOAD_VALUE ADD_TWO_VALUES PRINT_ANSWER  As stated before, my interpreter doesn&amp;rsquo;t care about lexing, parsing nor compiling.</description>
    </item>
    
    <item>
      <title>Starting a Go interpreter</title>
      <link>https://sbinet.github.io/posts/2016-09-07-start-interpreter/</link>
      <pubDate>Wed, 07 Sep 2016 10:37:07 +0200</pubDate>
      
      <guid>https://sbinet.github.io/posts/2016-09-07-start-interpreter/</guid>
      <description>In this series of posts, I&amp;rsquo;ll try to explain how one can write an interpreter in Go and for Go. If, like me, you lack a bit in terms of interpreters know-how, you should be in for a treat.
Introduction Go is starting to get traction in the science and data science communities. And, why not? Go is fast to compile and run, is statically typed and thus presents a nice &amp;ldquo;edit/compile/run&amp;rdquo; development cycle.</description>
    </item>
    
    <item>
      <title>My first post</title>
      <link>https://sbinet.github.io/posts/2016-08-31-hello/</link>
      <pubDate>Wed, 31 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://sbinet.github.io/posts/2016-08-31-hello/</guid>
      <description> Content This is the first of many-many posts.
sub-content package main func main() { println(&amp;quot;hello&amp;quot;) }  </description>
    </item>
    
  </channel>
</rss>